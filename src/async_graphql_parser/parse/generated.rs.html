<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/async-graphql-parser-7.0.2/src/parse/generated.rs`."><title>generated.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="async_graphql_parser" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../../../static.files/src-script-3280b574d94e47b4.js"></script><script defer src="../../../src-files.js"></script><script defer src="../../../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
</pre></div><pre class="rust"><code>
<span class="doccomment">//! This is @generated code, do not edit by hand.
//! See `graphql.pest` and `tests/codegen.rs`.
</span><span class="attr">#![allow(unused_attributes)]
</span><span class="kw">use </span><span class="kw">super</span>::GraphQLParser;

# [doc = <span class="string">&quot;&quot;</span>] # [allow (dead_code , non_camel_case_types , clippy :: upper_case_acronyms)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub enum </span>Rule { # [doc = <span class="string">&quot;End-of-input&quot;</span>] EOI , r#WHITESPACE , r#COMMENT , r#line_terminator , r#executable_document , r#executable_definition , r#operation_definition , r#named_operation_definition , r#variable_definitions , r#variable_definition , r#selection_set , r#selection , r#field , r#alias , r#fragment_spread , r#inline_fragment , r#fragment_definition , r#type_condition , r#service_document , r#type_system_definition , r#schema_definition , r#operation_type_definition , r#type_definition , r#scalar_type , r#object_type , r#implements_interfaces , r#interface_type , r#fields_definition , r#field_definition , r#union_type , r#union_member_types , r#enum_type , r#enum_values , r#enum_value_definition , r#input_object_type , r#input_fields_definition , r#extend , r#directive_definition , r#repeatable , r#directive_locations , r#directive_location , r#arguments_definition , r#input_value_definition , r#operation_type , r#default_value , r#type_ , r#const_value , r#value , r#variable , r#number , r#float , r#fractional , r#exponent , r#int , r#string , r#block_string_content , r#block_string_character , r#string_content , r#string_character , r#unicode_scalar_value_hex , r#boolean , r#null , r#enum_value , r#const_list , r#list , r#const_object , r#object , r#const_object_field , r#object_field , r#const_directives , r#directives , r#const_directive , r#directive , r#const_arguments , r#arguments , r#const_argument , r#argument , r#name_start , r#name } <span class="kw">impl </span>Rule { <span class="kw">pub fn </span>all_rules () -&gt; &amp; <span class="lifetime">&#39;static </span>[Rule] { &amp; [Rule :: r#WHITESPACE , Rule :: r#COMMENT , Rule :: r#line_terminator , Rule :: r#executable_document , Rule :: r#executable_definition , Rule :: r#operation_definition , Rule :: r#named_operation_definition , Rule :: r#variable_definitions , Rule :: r#variable_definition , Rule :: r#selection_set , Rule :: r#selection , Rule :: r#field , Rule :: r#alias , Rule :: r#fragment_spread , Rule :: r#inline_fragment , Rule :: r#fragment_definition , Rule :: r#type_condition , Rule :: r#service_document , Rule :: r#type_system_definition , Rule :: r#schema_definition , Rule :: r#operation_type_definition , Rule :: r#type_definition , Rule :: r#scalar_type , Rule :: r#object_type , Rule :: r#implements_interfaces , Rule :: r#interface_type , Rule :: r#fields_definition , Rule :: r#field_definition , Rule :: r#union_type , Rule :: r#union_member_types , Rule :: r#enum_type , Rule :: r#enum_values , Rule :: r#enum_value_definition , Rule :: r#input_object_type , Rule :: r#input_fields_definition , Rule :: r#extend , Rule :: r#directive_definition , Rule :: r#repeatable , Rule :: r#directive_locations , Rule :: r#directive_location , Rule :: r#arguments_definition , Rule :: r#input_value_definition , Rule :: r#operation_type , Rule :: r#default_value , Rule :: r#type_ , Rule :: r#const_value , Rule :: r#value , Rule :: r#variable , Rule :: r#number , Rule :: r#float , Rule :: r#fractional , Rule :: r#exponent , Rule :: r#int , Rule :: r#string , Rule :: r#block_string_content , Rule :: r#block_string_character , Rule :: r#string_content , Rule :: r#string_character , Rule :: r#unicode_scalar_value_hex , Rule :: r#boolean , Rule :: r#null , Rule :: r#enum_value , Rule :: r#const_list , Rule :: r#list , Rule :: r#const_object , Rule :: r#object , Rule :: r#const_object_field , Rule :: r#object_field , Rule :: r#const_directives , Rule :: r#directives , Rule :: r#const_directive , Rule :: r#directive , Rule :: r#const_arguments , Rule :: r#arguments , Rule :: r#const_argument , Rule :: r#argument , Rule :: r#name_start , Rule :: r#name] } } # [allow (clippy :: all)] <span class="kw">impl </span>:: pest :: Parser &lt; Rule &gt; <span class="kw">for </span>GraphQLParser { <span class="kw">fn </span>parse &lt; <span class="lifetime">&#39;i </span>&gt; (rule : Rule , input : &amp; <span class="lifetime">&#39;i </span>str) -&gt; :: std :: result :: <span class="prelude-ty">Result </span>&lt; :: pest :: iterators :: Pairs &lt; <span class="lifetime">&#39;i </span>, Rule &gt; , :: pest :: error :: Error &lt; Rule &gt; &gt; { <span class="kw">mod </span>rules { # ! [allow (clippy :: upper_case_acronyms)] <span class="kw">pub mod </span>hidden { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>skip (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="kw">if </span>state . atomicity () == :: pest :: Atomicity :: NonAtomic { state . sequence (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: visible :: COMMENT (state) . and_then (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) }) }) }) }) }) } <span class="kw">else </span>{ <span class="prelude-val">Ok </span>(state) } } } <span class="kw">pub mod </span>visible { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#WHITESPACE (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string (<span class="string">&quot; &quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;,&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;\t&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;\u{feff}&quot;</span>) }) . or_else (| state | { <span class="self">self </span>:: r#line_terminator (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#COMMENT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;#&quot;</span>) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#line_terminator (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#line_terminator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#line_terminator , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string (<span class="string">&quot;\r\n&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\r&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;\n&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#executable_document (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#executable_document , | state | { state . sequence (| state | { <span class="self">self </span>:: r#SOI (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#executable_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#executable_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#executable_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#EOI (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#executable_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#executable_definition , | state | { <span class="self">self </span>:: r#operation_definition (state) . or_else (| state | { <span class="self">self </span>:: r#fragment_definition (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#operation_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#operation_definition , | state | { <span class="self">self </span>:: r#named_operation_definition (state) . or_else (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#named_operation_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#named_operation_definition , | state | { state . sequence (| state | { <span class="self">self </span>:: r#operation_type (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#name (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#variable_definitions (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#variable_definitions (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#variable_definitions , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;(&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#variable_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#variable_definition (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;)&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#variable_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#variable_definition , | state | { state . sequence (| state | { <span class="self">self </span>:: r#variable (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#type_ (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#default_value (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#selection_set (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#selection_set , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;{&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#selection (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#selection (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#selection (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#selection (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#selection , | state | { <span class="self">self </span>:: r#field (state) . or_else (| state | { <span class="self">self </span>:: r#inline_fragment (state) }) . or_else (| state | { <span class="self">self </span>:: r#fragment_spread (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#field (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#field , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#alias (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#arguments (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#alias (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#alias , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#fragment_spread (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#fragment_spread , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;...&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#type_condition (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inline_fragment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inline_fragment , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;...&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#type_condition (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#fragment_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#fragment_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;fragment&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#type_condition (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#type_condition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#type_condition , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;on&quot;</span>) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#WHITESPACE (state) . and_then (| state | { state . repeat (| state | { <span class="self">self </span>:: r#WHITESPACE (state) }) }) }) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#service_document (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#service_document , | state | { state . sequence (| state | { <span class="self">self </span>:: r#SOI (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#type_system_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#type_system_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#type_system_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#EOI (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#type_system_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#type_system_definition , | state | { <span class="self">self </span>:: r#schema_definition (state) . or_else (| state | { <span class="self">self </span>:: r#type_definition (state) }) . or_else (| state | { <span class="self">self </span>:: r#directive_definition (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#schema_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#schema_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;schema&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;{&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#operation_type_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#operation_type_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#operation_type_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;schema&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;{&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#operation_type_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#operation_type_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#operation_type_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#operation_type_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#operation_type_definition , | state | { state . sequence (| state | { <span class="self">self </span>:: r#operation_type (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#type_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#type_definition , | state | { <span class="self">self </span>:: r#scalar_type (state) . or_else (| state | { <span class="self">self </span>:: r#object_type (state) }) . or_else (| state | { <span class="self">self </span>:: r#interface_type (state) }) . or_else (| state | { <span class="self">self </span>:: r#union_type (state) }) . or_else (| state | { <span class="self">self </span>:: r#enum_type (state) }) . or_else (| state | { <span class="self">self </span>:: r#input_object_type (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#scalar_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#scalar_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;scalar&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;scalar&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#object_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#object_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;type&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#fields_definition (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;type&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#fields_definition (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) . or_else (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#implements_interfaces (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#implements_interfaces , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;implements&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string (<span class="string">&quot;&amp;&quot;</span>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;&amp;&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;&amp;&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#interface_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#interface_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;interface&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#fields_definition (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;interface&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#fields_definition (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#fields_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#fields_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;{&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#field_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#field_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#field_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#field_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#field_definition , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#arguments_definition (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#type_ (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#union_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#union_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;union&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#union_member_types (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;union&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#union_member_types (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#union_member_types (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#union_member_types , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;=&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string (<span class="string">&quot;|&quot;</span>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;|&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;|&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#enum_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#enum_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;enum&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#enum_values (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;enum&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#enum_values (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#enum_values (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#enum_values , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;{&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#enum_value_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#enum_value_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#enum_value_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#enum_value_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#enum_value_definition , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#enum_value (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#input_object_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#input_object_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;input&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#input_fields_definition (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;input&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#input_fields_definition (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#input_fields_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#input_fields_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;{&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#input_value_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#input_value_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#input_value_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#extend (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#extend , | state | { state . match_string (<span class="string">&quot;extend&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directive_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directive_definition , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;directive&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;@&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#arguments_definition (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#repeatable (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;on&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#directive_locations (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeatable (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeatable , | state | { state . optional (| state | { state . match_string (<span class="string">&quot;repeatable&quot;</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directive_locations (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directive_locations , | state | { state . sequence (| state | { state . optional (| state | { state . match_string (<span class="string">&quot;|&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#directive_location (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;|&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#directive_location (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;|&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#directive_location (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directive_location (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directive_location , | state | { state . match_string (<span class="string">&quot;QUERY&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;MUTATION&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;SUBSCRIPTION&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;FIELD_DEFINITION&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;FIELD&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;FRAGMENT_DEFINITION&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;FRAGMENT_SPREAD&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;INLINE_FRAGMENT&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;VARIABLE_DEFINITION&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;SCHEMA&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;SCALAR&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;OBJECT&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;ARGUMENT_DEFINITION&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;INTERFACE&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;UNION&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;ENUM_VALUE&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;ENUM&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;INPUT_OBJECT&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;INPUT_FIELD_DEFINITION&quot;</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#arguments_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#arguments_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;(&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#input_value_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#input_value_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#input_value_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;)&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#input_value_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#input_value_definition , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#type_ (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#default_value (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#operation_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#operation_type , | state | { state . match_string (<span class="string">&quot;query&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;mutation&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;subscription&quot;</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#default_value (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#default_value , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;=&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#const_value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#type_ (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#type_ , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;[&quot;</span>) . and_then (| state | { <span class="self">self </span>:: r#type_ (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;]&quot;</span>) }) }) }) . and_then (| state | { state . optional (| state | { state . match_string (<span class="string">&quot;!&quot;</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_value (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_value , | state | { <span class="self">self </span>:: r#number (state) . or_else (| state | { <span class="self">self </span>:: r#string (state) }) . or_else (| state | { <span class="self">self </span>:: r#boolean (state) }) . or_else (| state | { <span class="self">self </span>:: r#null (state) }) . or_else (| state | { <span class="self">self </span>:: r#enum_value (state) }) . or_else (| state | { <span class="self">self </span>:: r#const_list (state) }) . or_else (| state | { <span class="self">self </span>:: r#const_object (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#value (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#value , | state | { <span class="self">self </span>:: r#variable (state) . or_else (| state | { <span class="self">self </span>:: r#number (state) }) . or_else (| state | { <span class="self">self </span>:: r#string (state) }) . or_else (| state | { <span class="self">self </span>:: r#boolean (state) }) . or_else (| state | { <span class="self">self </span>:: r#null (state) }) . or_else (| state | { <span class="self">self </span>:: r#enum_value (state) }) . or_else (| state | { <span class="self">self </span>:: r#list (state) }) . or_else (| state | { <span class="self">self </span>:: r#object (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#variable (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#variable , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;$&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#number (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#number , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="self">self </span>:: r#float (state) . or_else (| state | { <span class="self">self </span>:: r#int (state) }) . and_then (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#name_start (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#float (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#float , | state | { state . sequence (| state | { <span class="self">self </span>:: r#int (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#fractional (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#exponent (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#fractional (state) }) . or_else (| state | { <span class="self">self </span>:: r#exponent (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#fractional (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#fractional , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;.&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#exponent (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#exponent , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;E&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;e&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string (<span class="string">&quot;+&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;-&quot;</span>) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#int (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#int , | state | { state . sequence (| state | { state . optional (| state | { state . match_string (<span class="string">&quot;-&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;0&quot;</span>) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#ASCII_NONZERO_DIGIT (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#string , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;\&quot;\&quot;\&quot;&quot;</span>) . and_then (| state | { <span class="self">self </span>:: r#block_string_content (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;\&quot;\&quot;\&quot;&quot;</span>) }) }) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;\&quot;&quot;</span>) . and_then (| state | { <span class="self">self </span>:: r#string_content (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;\&quot;&quot;</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#block_string_content (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#block_string_content , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . repeat (| state | { <span class="self">self </span>:: r#block_string_character (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#block_string_character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#block_string_character , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;\&quot;\&quot;\&quot;&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\\\&quot;\&quot;\&quot;&quot;</span>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) . or_else (| state | { state . match_string (<span class="string">&quot;\\\&quot;\&quot;\&quot;&quot;</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string_content (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#string_content , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . repeat (| state | { <span class="self">self </span>:: r#string_character (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string_character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#string_character , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;\&quot;&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\\&quot;</span>) }) . or_else (| state | { <span class="self">self </span>:: r#line_terminator (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;\\&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;\&quot;&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\\&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;/&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;b&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;f&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;n&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;r&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;t&quot;</span>) }) }) }) }) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;\\u&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#unicode_scalar_value_hex (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#unicode_scalar_value_hex (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#unicode_scalar_value_hex , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . sequence (| state | { state . match_insensitive (<span class="string">&quot;d&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_range (<span class="string">&#39;8&#39; </span>.. <span class="string">&#39;9&#39;</span>) . or_else (| state | { state . match_range (<span class="string">&#39;a&#39; </span>.. <span class="string">&#39;f&#39;</span>) }) . or_else (| state | { state . match_range (<span class="string">&#39;A&#39; </span>.. <span class="string">&#39;F&#39;</span>) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_HEX_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_HEX_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_HEX_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_HEX_DIGIT (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#boolean (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#boolean , | state | { state . match_string (<span class="string">&quot;true&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;false&quot;</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#null (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#null , | state | { state . match_string (<span class="string">&quot;null&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#enum_value (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#enum_value , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#boolean (state) . or_else (| state | { <span class="self">self </span>:: r#null (state) }) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_list (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_list , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;[&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_value (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#const_value (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;]&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#list (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#list , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;[&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#value (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#value (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;]&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_object (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_object , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;{&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_object_field (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#const_object_field (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#object (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#object , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;{&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#object_field (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#object_field (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_object_field (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_object_field , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#const_value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#object_field (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#object_field , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_directives (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_directives , | state | { state . sequence (| state | { <span class="self">self </span>:: r#const_directive (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directive (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#const_directive (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directives (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directives , | state | { state . sequence (| state | { <span class="self">self </span>:: r#directive (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#directive (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#directive (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_directive (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_directive , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;@&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_arguments (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directive (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directive , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;@&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#arguments (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_arguments (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_arguments , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;(&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#const_argument (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_argument (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#const_argument (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;)&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#arguments (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#arguments , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;(&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#argument (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#argument (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#argument (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;)&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_argument (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_argument , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#const_value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#argument (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#argument , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;:&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#name_start (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#name_start , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#ASCII_ALPHA (state) . or_else (| state | { state . match_string (<span class="string">&quot;_&quot;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#name (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#name , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name_start (state) . and_then (| state | { state . repeat (| state | { <span class="self">self </span>:: r#ASCII_ALPHA (state) . or_else (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) . or_else (| state | { state . match_string (<span class="string">&quot;_&quot;</span>) }) }) }) }) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ANY (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . skip (<span class="number">1</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>EOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: EOI , | state | state . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>SOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . start_of_input () } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ASCII_DIGIT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">&#39;0&#39; </span>..<span class="string">&#39;9&#39;</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ASCII_NONZERO_DIGIT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">&#39;1&#39; </span>..<span class="string">&#39;9&#39;</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ASCII_HEX_DIGIT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">&#39;0&#39; </span>..<span class="string">&#39;9&#39;</span>) . or_else (| state | state . match_range (<span class="string">&#39;a&#39; </span>..<span class="string">&#39;f&#39;</span>)) . or_else (| state | state . match_range (<span class="string">&#39;A&#39; </span>..<span class="string">&#39;F&#39;</span>)) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ASCII_ALPHA (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">&#39;a&#39; </span>..<span class="string">&#39;z&#39;</span>) . or_else (| state | state . match_range (<span class="string">&#39;A&#39; </span>..<span class="string">&#39;Z&#39;</span>)) } } <span class="kw">pub use </span><span class="self">self </span>:: visible :: * ; } :: pest :: state (input , | state | { <span class="kw">match </span>rule { Rule :: r#WHITESPACE =&gt; rules :: r#WHITESPACE (state) , Rule :: r#COMMENT =&gt; rules :: r#COMMENT (state) , Rule :: r#line_terminator =&gt; rules :: r#line_terminator (state) , Rule :: r#executable_document =&gt; rules :: r#executable_document (state) , Rule :: r#executable_definition =&gt; rules :: r#executable_definition (state) , Rule :: r#operation_definition =&gt; rules :: r#operation_definition (state) , Rule :: r#named_operation_definition =&gt; rules :: r#named_operation_definition (state) , Rule :: r#variable_definitions =&gt; rules :: r#variable_definitions (state) , Rule :: r#variable_definition =&gt; rules :: r#variable_definition (state) , Rule :: r#selection_set =&gt; rules :: r#selection_set (state) , Rule :: r#selection =&gt; rules :: r#selection (state) , Rule :: r#field =&gt; rules :: r#field (state) , Rule :: r#alias =&gt; rules :: r#alias (state) , Rule :: r#fragment_spread =&gt; rules :: r#fragment_spread (state) , Rule :: r#inline_fragment =&gt; rules :: r#inline_fragment (state) , Rule :: r#fragment_definition =&gt; rules :: r#fragment_definition (state) , Rule :: r#type_condition =&gt; rules :: r#type_condition (state) , Rule :: r#service_document =&gt; rules :: r#service_document (state) , Rule :: r#type_system_definition =&gt; rules :: r#type_system_definition (state) , Rule :: r#schema_definition =&gt; rules :: r#schema_definition (state) , Rule :: r#operation_type_definition =&gt; rules :: r#operation_type_definition (state) , Rule :: r#type_definition =&gt; rules :: r#type_definition (state) , Rule :: r#scalar_type =&gt; rules :: r#scalar_type (state) , Rule :: r#object_type =&gt; rules :: r#object_type (state) , Rule :: r#implements_interfaces =&gt; rules :: r#implements_interfaces (state) , Rule :: r#interface_type =&gt; rules :: r#interface_type (state) , Rule :: r#fields_definition =&gt; rules :: r#fields_definition (state) , Rule :: r#field_definition =&gt; rules :: r#field_definition (state) , Rule :: r#union_type =&gt; rules :: r#union_type (state) , Rule :: r#union_member_types =&gt; rules :: r#union_member_types (state) , Rule :: r#enum_type =&gt; rules :: r#enum_type (state) , Rule :: r#enum_values =&gt; rules :: r#enum_values (state) , Rule :: r#enum_value_definition =&gt; rules :: r#enum_value_definition (state) , Rule :: r#input_object_type =&gt; rules :: r#input_object_type (state) , Rule :: r#input_fields_definition =&gt; rules :: r#input_fields_definition (state) , Rule :: r#extend =&gt; rules :: r#extend (state) , Rule :: r#directive_definition =&gt; rules :: r#directive_definition (state) , Rule :: r#repeatable =&gt; rules :: r#repeatable (state) , Rule :: r#directive_locations =&gt; rules :: r#directive_locations (state) , Rule :: r#directive_location =&gt; rules :: r#directive_location (state) , Rule :: r#arguments_definition =&gt; rules :: r#arguments_definition (state) , Rule :: r#input_value_definition =&gt; rules :: r#input_value_definition (state) , Rule :: r#operation_type =&gt; rules :: r#operation_type (state) , Rule :: r#default_value =&gt; rules :: r#default_value (state) , Rule :: r#type_ =&gt; rules :: r#type_ (state) , Rule :: r#const_value =&gt; rules :: r#const_value (state) , Rule :: r#value =&gt; rules :: r#value (state) , Rule :: r#variable =&gt; rules :: r#variable (state) , Rule :: r#number =&gt; rules :: r#number (state) , Rule :: r#float =&gt; rules :: r#float (state) , Rule :: r#fractional =&gt; rules :: r#fractional (state) , Rule :: r#exponent =&gt; rules :: r#exponent (state) , Rule :: r#int =&gt; rules :: r#int (state) , Rule :: r#string =&gt; rules :: r#string (state) , Rule :: r#block_string_content =&gt; rules :: r#block_string_content (state) , Rule :: r#block_string_character =&gt; rules :: r#block_string_character (state) , Rule :: r#string_content =&gt; rules :: r#string_content (state) , Rule :: r#string_character =&gt; rules :: r#string_character (state) , Rule :: r#unicode_scalar_value_hex =&gt; rules :: r#unicode_scalar_value_hex (state) , Rule :: r#boolean =&gt; rules :: r#boolean (state) , Rule :: r#null =&gt; rules :: r#null (state) , Rule :: r#enum_value =&gt; rules :: r#enum_value (state) , Rule :: r#const_list =&gt; rules :: r#const_list (state) , Rule :: r#list =&gt; rules :: r#list (state) , Rule :: r#const_object =&gt; rules :: r#const_object (state) , Rule :: r#object =&gt; rules :: r#object (state) , Rule :: r#const_object_field =&gt; rules :: r#const_object_field (state) , Rule :: r#object_field =&gt; rules :: r#object_field (state) , Rule :: r#const_directives =&gt; rules :: r#const_directives (state) , Rule :: r#directives =&gt; rules :: r#directives (state) , Rule :: r#const_directive =&gt; rules :: r#const_directive (state) , Rule :: r#directive =&gt; rules :: r#directive (state) , Rule :: r#const_arguments =&gt; rules :: r#const_arguments (state) , Rule :: r#arguments =&gt; rules :: r#arguments (state) , Rule :: r#const_argument =&gt; rules :: r#const_argument (state) , Rule :: r#argument =&gt; rules :: r#argument (state) , Rule :: r#name_start =&gt; rules :: r#name_start (state) , Rule :: r#name =&gt; rules :: r#name (state) , Rule :: EOI =&gt; rules :: EOI (state) } }) } }</code></pre></div></section></main></body></html>